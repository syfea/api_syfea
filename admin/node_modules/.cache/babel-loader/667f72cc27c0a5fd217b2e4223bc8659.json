{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.transformJsonLdDocumentToReactAdminDocument = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _reactAdmin = require(\"react-admin\");\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isplainobject\"));\n\nvar _fetchHydra = _interopRequireDefault(require(\"./fetchHydra\"));\n\nvar ReactAdminDocument =\n/*#__PURE__*/\nfunction () {\n  function ReactAdminDocument(obj) {\n    (0, _classCallCheck2.default)(this, ReactAdminDocument);\n    Object.assign(this, obj, {\n      originId: obj.id,\n      id: obj['@id']\n    });\n  }\n  /**\n   * @return {string}\n   */\n\n\n  (0, _createClass2.default)(ReactAdminDocument, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"[object \".concat(this.id, \"]\");\n    }\n  }]);\n  return ReactAdminDocument;\n}();\n/**\n * Local cache containing embedded documents.\n * It will be used to prevent useless extra HTTP query if the relation is displayed.\n *\n * @type {Map}\n */\n\n\nvar reactAdminDocumentsCache = new Map();\n/**\n * Transforms a JSON-LD document to a react-admin compatible document.\n *\n * @param {Object} document\n * @param {bool} clone\n *\n * @return {ReactAdminDocument}\n */\n\nvar transformJsonLdDocumentToReactAdminDocument = function transformJsonLdDocumentToReactAdminDocument(document) {\n  var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var addToCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (clone) {\n    // deep clone documents\n    document = JSON.parse(JSON.stringify(document));\n  } // The main document is a JSON-LD document, convert it and store it in the cache\n\n\n  if (document['@id']) {\n    document = new ReactAdminDocument(document);\n  } // Replace embedded objects by their IRIs, and store the object itself in the cache to reuse without issuing new HTTP requests.\n\n\n  Object.keys(document).forEach(function (key) {\n    // to-one\n    if ((0, _lodash.default)(document[key]) && document[key]['@id']) {\n      if (addToCache) {\n        reactAdminDocumentsCache[document[key]['@id']] = transformJsonLdDocumentToReactAdminDocument(document[key], false, false);\n      }\n\n      document[key] = document[key]['@id'];\n      return;\n    } // to-many\n\n\n    if (Array.isArray(document[key]) && document[key].length && (0, _lodash.default)(document[key][0]) && document[key][0]['@id']) {\n      document[key] = document[key].map(function (obj) {\n        if (addToCache) {\n          reactAdminDocumentsCache[obj['@id']] = transformJsonLdDocumentToReactAdminDocument(obj, false, false);\n        }\n\n        return obj['@id'];\n      });\n    }\n  });\n  return document;\n};\n/**\n * Maps react-admin queries to a Hydra powered REST API\n *\n * @see http://www.hydra-cg.com/\n *\n * @example\n * CREATE   => POST http://my.api.url/posts/123\n * DELETE   => DELETE http://my.api.url/posts/123\n * GET_LIST => GET http://my.api.url/posts\n * GET_MANY => GET http://my.api.url/posts/123, GET http://my.api.url/posts/456, GET http://my.api.url/posts/789\n * GET_ONE  => GET http://my.api.url/posts/123\n * UPDATE   => PUT http://my.api.url/posts/123\n */\n\n\nexports.transformJsonLdDocumentToReactAdminDocument = transformJsonLdDocumentToReactAdminDocument;\n\nvar _default = function _default(_ref) {\n  var entrypoint = _ref.entrypoint,\n      _ref$resources = _ref.resources,\n      resources = _ref$resources === void 0 ? [] : _ref$resources;\n  var httpClient = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _fetchHydra.default;\n  /**\n   * @param {Object} resource\n   * @param {Object} data\n   *\n   * @returns {Promise}\n   */\n\n  var convertReactAdminDataToHydraData = function convertReactAdminDataToHydraData(resource) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var fieldData = [];\n    resource.fields.forEach(function (_ref2) {\n      var name = _ref2.name,\n          normalizeData = _ref2.normalizeData;\n\n      if (!(name in data) || undefined === normalizeData) {\n        return;\n      }\n\n      fieldData[name] = normalizeData(data[name]);\n    });\n    var fieldDataKeys = Object.keys(fieldData);\n    var fieldDataValues = Object.values(fieldData);\n    return Promise.all(fieldDataValues).then(function (fieldData) {\n      var object = {};\n\n      for (var i = 0; i < fieldDataKeys.length; i++) {\n        object[fieldDataKeys[i]] = fieldData[i];\n      }\n\n      return (0, _objectSpread2.default)({}, data, object);\n    });\n  };\n  /**\n   * @param {Object} resource\n   * @param {Object} data\n   *\n   * @returns {Promise}\n   */\n\n\n  var transformReactAdminDataToRequestBody = function transformReactAdminDataToRequestBody(resource) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    resource = resources.find(function (_ref3) {\n      var name = _ref3.name;\n      return resource === name;\n    });\n\n    if (undefined === resource) {\n      return Promise.resolve(data);\n    }\n\n    return convertReactAdminDataToHydraData(resource, data).then(function (data) {\n      return undefined === resource.encodeData ? JSON.stringify(data) : resource.encodeData(data);\n    });\n  };\n  /**\n   * @param {string} type\n   * @param {string} resource\n   * @param {Object} params\n   *\n   * @returns {Object}\n   */\n\n\n  var convertReactAdminRequestToHydraRequest = function convertReactAdminRequestToHydraRequest(type, resource, params) {\n    var entrypointUrl = new URL(entrypoint, window.location.href);\n    var collectionUrl = new URL(\"\".concat(entrypoint, \"/\").concat(resource), entrypointUrl);\n    var itemUrl = new URL(params.id, entrypointUrl);\n\n    switch (type) {\n      case _reactAdmin.CREATE:\n        return transformReactAdminDataToRequestBody(resource, params.data).then(function (body) {\n          return {\n            options: {\n              body: body,\n              method: 'POST'\n            },\n            url: collectionUrl\n          };\n        });\n\n      case _reactAdmin.DELETE:\n        return Promise.resolve({\n          options: {\n            method: 'DELETE'\n          },\n          url: itemUrl\n        });\n\n      case _reactAdmin.GET_LIST:\n        {\n          var _params$pagination = params.pagination,\n              page = _params$pagination.page,\n              perPage = _params$pagination.perPage,\n              _params$sort = params.sort,\n              field = _params$sort.field,\n              order = _params$sort.order;\n          if (order) collectionUrl.searchParams.set(\"order[\".concat(field, \"]\"), order);\n          if (page) collectionUrl.searchParams.set('page', page);\n          if (perPage) collectionUrl.searchParams.set('perPage', perPage);\n\n          if (params.filter) {\n            Object.keys(params.filter).forEach(function (key) {\n              var filterValue = params.filter[key];\n\n              if (!(0, _lodash.default)(filterValue)) {\n                collectionUrl.searchParams.set(key, params.filter[key]);\n                return;\n              }\n\n              Object.keys(filterValue).forEach(function (subKey) {\n                collectionUrl.searchParams.set(\"\".concat(key, \"[\").concat(subKey, \"]\"), filterValue[subKey]);\n              });\n            });\n          }\n\n          return Promise.resolve({\n            options: {},\n            url: collectionUrl\n          });\n        }\n\n      case _reactAdmin.GET_MANY_REFERENCE:\n        if (params.target) {\n          collectionUrl.searchParams.set(params.target, params.id);\n        }\n\n        return Promise.resolve({\n          options: {},\n          url: collectionUrl\n        });\n\n      case _reactAdmin.GET_ONE:\n        return Promise.resolve({\n          options: {},\n          url: itemUrl\n        });\n\n      case _reactAdmin.UPDATE:\n        return transformReactAdminDataToRequestBody(resource, params.data).then(function (body) {\n          return {\n            options: {\n              body: body,\n              method: 'PUT'\n            },\n            url: itemUrl\n          };\n        });\n\n      default:\n        throw new Error(\"Unsupported fetch action type \".concat(type));\n    }\n  };\n  /**\n   * @param {string} resource\n   * @param {Object} data\n   *\n   * @returns {Promise}\n   */\n\n\n  var convertHydraDataToReactAdminData = function convertHydraDataToReactAdminData(resource) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    resource = resources.find(function (_ref4) {\n      var name = _ref4.name;\n      return resource === name;\n    });\n\n    if (undefined === resource) {\n      return Promise.resolve(data);\n    }\n\n    var fieldData = {};\n    resource.fields.forEach(function (_ref5) {\n      var name = _ref5.name,\n          denormalizeData = _ref5.denormalizeData;\n\n      if (!(name in data) || undefined === denormalizeData) {\n        return;\n      }\n\n      fieldData[name] = denormalizeData(data[name]);\n    });\n    var fieldDataKeys = Object.keys(fieldData);\n    var fieldDataValues = Object.values(fieldData);\n    return Promise.all(fieldDataValues).then(function (fieldData) {\n      var object = {};\n\n      for (var i = 0; i < fieldDataKeys.length; i++) {\n        object[fieldDataKeys[i]] = fieldData[i];\n      }\n\n      return (0, _objectSpread2.default)({}, data, object);\n    });\n  };\n  /**\n   * @param {Object} response\n   * @param {string} resource\n   * @param {string} type\n   *\n   * @returns {Promise}\n   */\n\n\n  var convertHydraResponseToReactAdminResponse = function convertHydraResponseToReactAdminResponse(type, resource, response) {\n    switch (type) {\n      case _reactAdmin.GET_LIST:\n      case _reactAdmin.GET_MANY_REFERENCE:\n        // TODO: support other prefixes than \"hydra:\"\n        return Promise.resolve(response.json['hydra:member'].map(transformJsonLdDocumentToReactAdminDocument)).then(function (data) {\n          return Promise.all(data.map(function (data) {\n            return convertHydraDataToReactAdminData(resource, data);\n          }));\n        }).then(function (data) {\n          return {\n            data: data,\n            total: response.json['hydra:totalItems']\n          };\n        });\n\n      case _reactAdmin.DELETE:\n        return Promise.resolve({\n          data: {\n            id: null\n          }\n        });\n\n      default:\n        return Promise.resolve(transformJsonLdDocumentToReactAdminDocument(response.json)).then(function (data) {\n          return convertHydraDataToReactAdminData(resource, data);\n        }).then(function (data) {\n          return {\n            data: data\n          };\n        });\n    }\n  };\n  /**\n   * @param {string} type\n   * @param {string} resource\n   * @param {Object} params\n   *\n   * @returns {Promise}\n   */\n\n\n  var fetchApi = function fetchApi(type, resource, params) {\n    // Hydra doesn't handle MANY requests, so we fallback to calling the ONE request n times instead\n    switch (type) {\n      case _reactAdmin.GET_MANY:\n        return Promise.all(params.ids.map(function (id) {\n          return reactAdminDocumentsCache[id] ? Promise.resolve({\n            data: reactAdminDocumentsCache[id]\n          }) : fetchApi(_reactAdmin.GET_ONE, resource, {\n            id: id\n          });\n        })).then(function (responses) {\n          return {\n            data: responses.map(function (_ref6) {\n              var data = _ref6.data;\n              return data;\n            })\n          };\n        });\n\n      case _reactAdmin.DELETE_MANY:\n        return Promise.all(params.ids.map(function (id) {\n          return fetchApi(_reactAdmin.DELETE, resource, {\n            id: id\n          });\n        })).then(function (responses) {\n          return {\n            data: []\n          };\n        });\n\n      default:\n        return convertReactAdminRequestToHydraRequest(type, resource, params).then(function (_ref7) {\n          var url = _ref7.url,\n              options = _ref7.options;\n          return httpClient(url, options);\n        }).then(function (response) {\n          return convertHydraResponseToReactAdminResponse(type, resource, response);\n        });\n    }\n  };\n\n  return fetchApi;\n};\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}